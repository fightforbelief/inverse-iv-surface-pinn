数据准备与初步处理（Step 1）

代码位置：src/data_loader.py 和 src/preprocessing.py（以及Notebook验证）。

实现内容：编写数据加载函数，例如load_raw_data(path)，读取data/raw/中的Parquet文件为Pandas DataFrame。随后在preprocessing.py中实现清洗与格式整理函数，如clean_data(df)：处理缺失值和异常值（移除无效的期权价格、到期日已过或负值的数据点等），计算必要字段（例如标的现价S、执行价K、年化到期T、利率r和股息率q，可从数据中获取或假定常量）。若原始数据未给出隐含波动率，则在此阶段利用Black–Scholes公式数值求解每个期权合约的隐含波动率供参考（可使用牛顿迭代或二分法求$\sigma$使BS价格匹配市场价）。此外，将执行价和标的价格归一化处理生成无量纲特征（如moneyness $K/S$或$\log(K/S)$）以输入模型，并按需要划分训练集和测试集数据。

目标：完成原始数据的读取和基本整理，确保后续模型训练所需输入特征和目标（期权市场价格或对应的隐含波动率）准备就绪。通过在notebooks/eda.ipynb中调用这些函数，初步验证数据正确性（例如打印样本数据、统计描述）并保存处理后的数据至data/processed/供后续步骤使用。

探索性数据分析（Step 2）

代码位置：notebooks/eda.ipynb。

实现内容：在Notebook中对预处理后的数据进行探索分析和可视化。一方面，绘制某一交易日期下SPY期权的隐含波动率曲面初始形状（若上一步计算了隐含波动率，可用market IV，否则可基于价格计算隐含波动率进行可视化），例如固定几组到期$T$绘制隐含波动率随行权价$K$的“微笑”曲线，或使用visualize.py中工具绘制三维表面图。另一方面，检查无套利性质在原始数据中是否有违背之处，如是否存在某些行权价范围的价格非凸现象或者不同到期日之间价格异常（这可帮助确定约束的侧重点）。记录数据的典型范围（如$K/S$范围、$T$分布），为模型输入选择提供依据。

目标：加深对数据的理解，明确隐含波动率曲面的特点（例如是否存在典型的微笑/skew形状），以及发现数据噪声或异常。EDA结果也将指导模型的设计和约束条件的选取（例如观察到隐含波动率随到期单调或非单调的情况）。这一步还验证了数据加载和处理流程的正确性，为后续建模打下基础。

构建隐含波动率曲面模型（Step 3）

代码位置：src/model.py。

实现内容：定义用于逼近$\sigma(K,T)$的神经网络结构。模型输入为两个维度（如归一化处理后的执行价和到期时间，建议使用$\log(K/S)$或moneyness和$T$），输出为对应条件下的隐含波动率$\sigma$。采用全连接前馈神经网络（MLP）为主干，配置若干隐藏层和适当的非线性激活函数，以保证函数的光滑性。为防止过拟合并保证输出平滑，可在网络中加入适度的正则化（例如L2正则）或使用较低复杂度的结构。若需确保输出满足一定的单调性或界限，可对网络输出层做特殊处理：例如通过softplus确保$\sigma>0$，通过构造单调网络层来保证$\sigma$对$K$的适当方向的单调性（视市场微笑形态而定）。由于目标是一个二元连续函数的近似，网络应足够灵活拟合市场曲面，同时保持合理的外插性。

目标：获得一个参数化的隐含波动率曲面函数$\sigma_\theta(K,T)$。这一函数形式上是连续可微的，作为PINN的基础。确保模型输出的$\sigma$在各点为正且平滑，为后续施加无套利约束和PDE约束做准备。代码实现完成后，可在training_experiments.ipynb中对模型做简单测试（比如输入一些$(K,T)$看输出是否在合理范围）。

引入Black–Scholes定价公式与损失计算（Step 4）

代码位置：src/black_scholes.py（定价函数）；src/train.py（损失集成）。

实现内容：在black_scholes.py中实现Black–Scholes欧式期权定价公式函数，如bs_price(S, K, T, r, q, sigma, option_type)，计算给定$\sigma$下理论期权价。可采用解析公式实现（利用累计标准正态分布函数）。接着，在train.py中设计损失函数：主要部分是期权价格拟合损失，即对于训练集中每个期权合约，将模型预测的$\sigma(K,T)$通过BS公式算出的价格与市场实际价格之差纳入均方误差损失。这样，神经网络通过最小化价格误差来“反演”出正确的波动率
medium.com
。由于BS公式可微，我们也可对$\sigma$的预测进行隐含波动率层面的误差计算，但直接用价格误差对市场更直接且避免在训练中二次求解$\sigma$。确保train.py中准备好获取输入$(K,T)$、通过模型得到$\sigma$、再通过BS函数得到价格并与真实价比较的流程。在这一阶段暂不引入约束项，先实现基本的有监督拟合损失。

目标：搭建起“模型–BS定价–损失”这一训练链路，为PINN核心训练做好准备。通过这一机制，模型参数将根据市场价格信号进行更新，实现隐含波动率的反演。此步完成后，可用少量数据在training_experiments.ipynb中做单步测试：例如取一两个期权样本，人工调整$\sigma$看BS价格输出是否接近实际价格，确保损失计算正确。代码层面，也可以编写一个简单的单元测试（在tests/目录）验证Black–Scholes公式实现的正确性。

集成PINN物理约束与无套利条件（Step 5）

代码位置：src/pinn_constraints.py（约束计算）；src/train.py（损失整合）。

实现内容：在pinn_constraints.py中实现物理约束和无套利条件相关的函数，并将其融入训练损失。首先，考虑Black–Scholes PDE约束：对于隐含波动率曲面$\sigma(K,T)$，严格来说Black–Scholes方程假定常数波动率，因此直接将$\sigma(K,T)$代入BS PDE并不适用。但我们可以转而利用风险中性定价原理和Dupire公式，将网络输出视作局部波动率的近似，从而对所对应的期权价格函数满足的偏微分方程施加惩罚。具体做法：利用自动微分对模型生成的期权价格（通过BS公式得到）计算关于$T$和$K$的偏导数，从而检查是否满足无套利PDE（Dupire方程） $ \frac{\partial C}{\partial T} = \frac{1}{2} \sigma_{\text{local}}^2(K,T) K^2 \frac{\partial^2 C}{\partial K^2} $（在简化假设下）等关系
medium.com
。由于直接应用Dupire可能复杂，可退而求其次，将静态无套利条件作为主要物理约束：包括(i) 日历无套利：要求总方差$\sigma^2(K,T)\cdot T$随到期单调不减，否则存在跨期套利
ar5iv.labs.arxiv.org
；(ii) 蝶式无套利：要求每个到期$T$上，期权价格对执行价$K$形成的曲线是凸的、单调递减的
ar5iv.labs.arxiv.org
（等价于隐含波动率曲面无负的局部波动率/概率密度）。实现上，可在pinn_constraints.py编写函数如calendar_arbitrage_penalty(model, sample_Ks, T1, T2)检查两到期$T1<T2$在若干执行价采样点的总方差单调性，违反则根据差值加入惩罚；butterfly_arbitrage_penalty(model, sample_T, Ks)计算某到期下不同$K$点处call价格的二阶差分，若发现凸性违背则加大损失。上述检查需要获取模型预测的$\sigma$或价格的梯度，可借助自动微分或在离散采样点上用有限差分近似。然后，在train.py中扩展损失函数为：总损失 $L_{\text{total}} = L_{\text{price_fit}} + \lambda_1 L_{\text{calendar}} + \lambda_2 L_{\text{butterfly}}$，其中$L_{\text{price_fit}}$是价格误差MSE，$L_{\text{calendar}}$和$L_{\text{butterfly}}$分别是上述无套利惩罚项，加权系数$\lambda_1,\lambda_2$需调试。通过这种多目标优化，使模型在拟合数据的同时内嵌地遵从金融约束
arxiv.org
medium.com
。

目标：形成Physics-Informed Neural Network的完整损失函数，确保训练过程既“拟合市场”又“遵守原理”。预期效果是模型不但能逼近市场期权价格，还天然满足无套利条件，无需事后矫正
arxiv.org
。在此步骤完成后，可使用部分数据训练模型若干epoch，在training_experiments.ipynb中观察损失各项的数值，确认约束违背现象逐步减少。例如，监控$L_{\text{butterfly}}$是否下降，保证模型输出的价格曲线愈发凸满足条件。

模型训练与调优（Step 6）

代码位置：主要在src/train.py（训练主循环）；使用training_experiments.ipynb进行调试和监控。

实现内容：编写训练过程代码，包括：初始化模型参数和优化器（如Adam），将数据批次输入模型计算损失，并迭代更新参数。结合前一步的总损失函数，适当调整各部分损失权重以平衡拟合精度和约束满足。实现早停或学习率调度以防止过拟合或训练震荡。同时，在训练循环中定期输出日志（如每隔若干epoch计算在验证集上的价格误差、以及无套利约束是否有违背）以便监控训练动态。如果数据量较大，可先使用小批量（mini-batch）训练，多epoch迭代直至收敛。此阶段可能需要多次实验调节网络结构（隐藏层大小、激活函数）和超参数（学习率、损失权重等）以获得最佳效果。记录每次实验的配置和结果，确保过程的可追溯性。

目标：训练出一个初步收敛的隐含波动率曲面模型。成功的标准包括：训练集上期权价格误差较小（例如均方误差降至接近市场报价噪音水平），同时无套利惩罚项也趋近于零（或满足预设阈值，表明模型基本无套利）。若发现模型难以同时满足拟合和约束，可返回上一步调整损失权重或网络结构重试。通过反复调优，在训练笔记本中获取一组较优的模型参数，并将最终模型保存至results/或models/目录，供后续评估使用。

模型结果评估与可视化（Step 7）

代码位置：src/evaluate.py（编程评估）；src/visualize.py（绘图函数）；使用training_experiments.ipynb或另建evaluation.ipynb汇报结果。

实现内容：在evaluate.py中实现评价指标计算。例如：平均绝对误差(MAE)和均方误差(MSE)用于衡量价格拟合好坏；对于无套利，可设计度量指标如“负概率密度占比”（计算有多少预测价格曲线的二阶导为负的比例）等。此外，评估模型对市场数据的拟合程度，可以比较不同执行价/到期组合下模型隐含波动率与市场隐含波动率（如果先前有计算单点IV），或者直接比较模型定价与市场价格的偏差分布。借助visualize.py，绘制出最终模型隐含波动率曲面，例如3D曲面图展示$\sigma(K,T)$，观察其平滑程度和形状是否合理；绘制无套利检验图：如选定几个到期，画出模型下期权价格-执行价曲线，与凸包对比验证其凸性；选定几个执行价，比较不同到期下模型给出的期权价格单调性。还可将最终曲面与原始市场离散隐含波动率点作对比图，展示模型平滑拟合效果。

目标：验证模型是否达到目标要求：平滑（曲面无噪音尖刺）、无套利（价格曲线单调凸且跨期合理）、拟合良好（误差在可接受范围）。评估过程应确认例如“模型预测的任一到期隐含波动率随执行价变化均形成合理的微笑形状且无局部反常”、“任一执行价下，随着到期延长，模型价格非下降”（满足日历单调）。在结果可视化上，生成的图表将用于项目报告或README中，以直观说明模型成功地重构了隐含波动率曲面并符合金融理论预期。

扩展多日期数据以增强泛化能力（Step 8）

代码位置：src/data_loader.py（扩充数据读取）；train.py（修改训练策略）。

实现内容：在单日期的数据基础上，考虑获取多个日期的SPY期权数据用于模型泛化测试。如果WRDS上可以方便地抓取不同日期的波动率曲面数据，建议在此步将数据获取和处理流程扩展为支持多个交易日。例如修改load_raw_data函数，允许输入日期参数批量读取多日数据，将其汇总标记上日期标签。然后有两种使用策略：(i) 训练阶段泛化：将多日期的数据混合用于训练模型，通过在不同市场环境下的数据训练，提高模型对更广泛波动率形状的拟合能力；(ii) 独立测试：或者仍用单日数据训练，但拿其它日期的数据作为纯测试集，检验模型对未见过市场的预测能力。若采用第一种策略，需在模型输入增加日期相关特征（例如日期索引或宏观状态），否则混合训练可能因不同日期的曲面差异过大而难以收敛。一个折衷是采用迁移学习：先用某日数据训练得到初始模型，再微调用于其他日。无论哪种方案，需在train.py中相应调整训练数据迭代策略，并在评估时对每个日期分别评估误差表现。

目标：强化模型的泛化能力。通过多日期数据的引入，可以验证模型并非仅仅记忆某天曲面，而是提取出了隐含波动率曲面的更一般模式。如果模型能够在其它日期的期权数据上保持较低的定价误差，并且输出曲面同样平滑无套利，则说明该PINN方法具有一定普适性。这一步将为项目提供更有说服力的实证效果。如结果不理想，则分析是模型容量不足还是市场状态差异太大，再决定是否需要针对每日期单独训练（在报告中需对此讨论）。

整理文档与复现验证（Step 9）

代码位置：README.md（完善说明）；可能补充脚本如run_all.py。

实现内容：将项目最终内容整理完善，确保他人可以从头运行得到相同结果。具体包括：在README.md中撰写清晰的使用说明（依赖环境安装、数据获取方法、如何运行训练及评估脚本、生成图表的方法等）。提供关键结果的截图或图示，解释项目达到的目标。为了复现方便，可编写一个一键运行的脚本run_all.py，顺序执行数据加载、模型训练和评估流程（或使用Makefile定义pipelines）。同时，在代码中设置固定的随机种子（利用utils.py里的函数）以保证每次运行结果一致，满足科研复现要求。最后，检查所有模块和脚本在一个干净环境下执行无误，包括多日期数据（如果使用）的下载或读取过程。

目标：提高项目的可复现性和可移植性。任何阅读此项目的人，都应能根据提供的说明重新训练模型并得到类似的隐含波动率曲面结果。通过整理文档和完善最终细节，确保项目开发目标全部达成并且成果可以推广使用。